# Assembly Language Programming with ARM

Dưới đây là một số hướng dẫn cơ bản của hợp ngữ ARM:

1. **MOV**: Đây là lệnh để di chuyển giá trị từ một địa chỉ đến một thanh ghi hoặc giữa các thanh ghi. Ví dụ:

   ```
   MOV r0, #10     ; Đặt giá trị 10 vào thanh ghi r0
   MOV r1, r2      ; Gán giá trị của r2 vào r1
   ```

2. **ADD, SUB**: Đây là các lệnh để thực hiện phép cộng và trừ. Ví dụ:

   ```
   ADD r3, r3, #5  ; r3 = r3 + 5
   SUB r4, r4, r5  ; r4 = r4 - r5
   ```

3. **CMP**: Lệnh này so sánh hai giá trị và cập nhật các cờ tương ứng. Ví dụ:

   ```
   CMP r0, r1      ; So sánh giá trị trong r0 và r1
   ```

4. **B**: Lệnh này là lệnh nhảy không điều kiện. Nó sẽ nhảy đến một địa chỉ khác trong chương trình. Ví dụ:

   ```
   B label_name    ; Nhảy đến địa chỉ được định nghĩa bởi label_name
   ```

5. **BEQ, BNE, BGT, BLT, ...**: Các lệnh nhảy có điều kiện, sẽ nhảy đến một địa chỉ khác dựa trên trạng thái của các cờ (VD: Bằng nhau, Không bằng nhau, Lớn hơn, Nhỏ hơn, ...).

6. **LDR, STR**: Lệnh này để đọc và ghi dữ liệu từ và vào bộ nhớ. Ví dụ:

   ```
   LDR r0, [r1]    ; Load giá trị từ địa chỉ chứa bởi r1 vào r0
   STR r2, [r3]    ; Ghi giá trị trong r2 vào địa chỉ chứa bởi r3
   ```

7. **LDM, STM**: Lệnh này để load và store nhiều thanh ghi cùng lúc. Ví dụ:

   ```
   LDMIA r4!, {r5, r6, r7}   ; Load giá trị từ r4, sau đó tăng r4 và gán vào r5, r6, r7.
   ```

8. **PUSH, POP**: Lệnh này được sử dụng để thêm và xóa dữ liệu từ ngăn xếp. Ví dụ:

   ```
   PUSH {r0, r1, r2}   ; Đẩy r0, r1, r2 vào ngăn xếp
   POP {r0, r1, r2}    ; Lấy dữ liệu từ ngăn xếp vào r0, r1, r2
   ```

9. **BL, BX**: Lệnh BL dùng để gọi một hàm con (subroutine). Lệnh BX dùng để nhảy về nơi đã gọi hàm con đó.

   ```
   BL function_name    ; Gọi hàm con tên function_name
   BX lr              ; Nhảy về nơi đã gọi hàm con
   ```

10. **NOP**: Lệnh này không thực hiện bất kỳ thao tác nào. Nó thường được sử dụng để tạo độ trễ hoặc đánh dấu vị trí trong mã.

   ```
   NOP   ; No operation
   ```


11. **ADRP**: Lệnh `ADRP` trong hợp ngữ ARM64 (AArch64) dùng để tính địa chỉ cơ bản (base address) của một biến hoặc mảng trong bộ nhớ. Lệnh này thường đi kèm với lệnh `LDR` để lấy giá trị tại địa chỉ đã tính toán.

Cú pháp của lệnh `ADRP` như sau:

```
ADRP Xd, label
```

Trong đó:
- `Xd` là thanh ghi đích (destination register) để lưu giá trị địa chỉ tính toán.
- `label` là nhãn (label) của biến hoặc mảng cần tính địa chỉ cơ bản.

Lệnh `ADRP` tính toán địa chỉ cơ bản bằng cách lấy địa chỉ của nhãn `label`, sau đó xóa đi 12 bit cuối của địa chỉ này (vì các địa chỉ thường được căn chỉnh ở dạng byte, và 12 bit cuối đại diện cho các offset trong một trang 4KB). Kết quả là địa chỉ cơ bản của biến hoặc mảng đó sẽ được lưu vào thanh ghi `Xd`.

Sau khi đã tính được địa chỉ cơ bản, bạn có thể sử dụng lệnh `LDR` hoặc các lệnh khác để truy xuất dữ liệu tại địa chỉ đó.

Ví dụ:

```assembly
ADRP X0, my_array    ; Tính địa chỉ cơ bản của mảng my_array và lưu vào X0
LDR  X1, [X0, #8]    ; Load giá trị tại địa chỉ X0 + 8 vào X1
```

Trong ví dụ trên, lệnh `ADRP` tính địa chỉ cơ bản của `my_array` và lưu vào thanh ghi `X0`, sau đó lệnh `LDR` sẽ load giá trị tại địa chỉ `X0 + 8` vào thanh ghi `X1`.


12. **B.EQ and B.GT**: Trong hợp ngữ ARM, các lệnh như `B.EQ` và `B.GT` đều là các lệnh nhảy có điều kiện (conditional branch instructions) và dùng để điều khiển luồng thực thi của chương trình dựa trên các điều kiện cụ thể.

13. `B.EQ`: Đây là lệnh nhảy có điều kiện "Branch if Equal". Nếu điều kiện bằng (equal) được đáp ứng, chương trình sẽ nhảy đến địa chỉ được chỉ định. Điều kiện này thường được kiểm tra bằng cách so sánh các thanh ghi.

14. `B.GT`: Đây là lệnh nhảy có điều kiện "Branch if Greater Than". Nếu điều kiện "lớn hơn" được đáp ứng, chương trình sẽ nhảy đến địa chỉ được chỉ định. Điều kiện này thường được kiểm tra bằng cách so sánh các thanh ghi.

Cú pháp chung của các lệnh nhảy có điều kiện trong ARM:

```assembly
B{condition} label
```

Trong đó:
- `{condition}` là điều kiện dựa trên kết quả của các lệnh trước đó (ví dụ: `EQ` cho "bằng", `GT` cho "lớn hơn").
- `label` là nhãn (label) của địa chỉ mục tiêu.

Ví dụ sử dụng:

```assembly
CMP R0, R1    ; So sánh R0 và R1
BEQ label     ; Nếu R0 bằng R1, thì nhảy đến label
BGT label     ; Nếu R0 lớn hơn R1, thì nhảy đến label
```

Trong ví dụ trên, nếu kết quả của so sánh `CMP` thỏa mãn điều kiện, chương trình sẽ nhảy đến địa chỉ được chỉ định bởi `label`.

------------------------------------------------------------

> Giải thích cho tôi về tất cả các thanh ghi kiến trúc arm ?
- Thanh ghi kiến trúc ARM (ARM Architecture Registers) là các thanh ghi đặc biệt trong vi điều khiển ARM (vi điều khiển loại RISC - Reduced Instruction Set Computer). Chúng có nhiệm vụ quan trọng trong việc điều khiển và điều phối các hoạt động của bộ xử lý ARM. Dưới đây là một số thanh ghi kiến trúc quan trọng trong vi điều khiển ARM:

1. **R0-R15**: Là 16 thanh ghi tổng hợp (general-purpose registers). Chúng được sử dụng để lưu trữ dữ liệu và kết quả của các phép toán.

2. **R0 - R7**: Còn được gọi là thanh ghi tham số (parameter registers) hoặc thanh ghi hàm (scratch registers). Chúng được sử dụng để truyền tham số và lưu giá trị tạm thời trong quá trình thực thi các hàm.

3. **R8 - R11**: Còn được gọi là thanh ghi cốt lõi (core registers). Chúng thường được sử dụng để lưu các giá trị quan trọng, và có thể bị ghi đè bởi các hàm con.

4. **R12**: Còn được gọi là thanh ghi IP (Intra-Procedure-call scratch register). Đôi khi được sử dụng để lưu trữ các giá trị tạm thời.

5. **R13**: Còn được gọi là thanh ghi SP (Stack Pointer). Nó lưu trữ địa chỉ của đỉnh của ngăn xếp (stack).

6. **R14**: Còn được gọi là thanh ghi LR (Link Register). Nó lưu trữ địa chỉ của lệnh sau khi gọi hàm.

7. **R15**: Còn được gọi là thanh ghi PC (Program Counter). Nó lưu trữ địa chỉ của lệnh đang được thực thi.

8. **CPSR**: Là thanh ghi trạng thái (Current Program Status Register) chứa các cờ và trạng thái của trình tự hiện tại.

9. **SPSR**: Là thanh ghi trạng thái không gian người dùng (Saved Program Status Register), được sử dụng để lưu trữ trạng thái trước khi có ngắt.

10. **FPSID**: Là thanh ghi ID số động của FPU (Floating Point Unit), được sử dụng cho tính toán số thực.

11. **FPSCR**: Là thanh ghi trạng thái của FPU.

12. **FPEXC**: Là thanh ghi trạng thái ngoại lệ của FPU.

Các thanh ghi này chơi một vai trò quan trọng trong việc thực thi các chương trình ARM và điều khiển các hoạt động của bộ xử lý. Chúng cũng thường được sử dụng trong việc tối ưu hóa mã máy và quản lý bộ nhớ.

> Các thanh ghi stack, con trỏ lệnh rip và save ebp trong asm thì ở kiến trức arm như nào ?

- Kiến trúc ARM không sử dụng cơ chế xếp ngăn (stack) và các thanh ghi như kiến trúc x86 truyền thống. Thay vào đó, nó sử dụng các thanh ghi tổng hợp (general-purpose registers) để thực hiện nhiều hoạt động, và không có các thanh ghi đặc biệt như EBP (Extended Base Pointer) hoặc EIP (Instruction Pointer) như trong kiến trúc x86.

- Một số lưu ý quan trọng về thanh ghi và xử lý của ARM:

1. **Thanh ghi tổng hợp (General-Purpose Registers)**: ARM sử dụng các thanh ghi tổng hợp (R0-R15) để lưu trữ dữ liệu và kết quả của các phép toán. Thanh ghi R15 thường được gọi là thanh ghi PC (Program Counter) và lưu trữ địa chỉ của lệnh đang được thực thi.

2. **Xếp ngăn (Stack)**: ARM sử dụng một xếp ngăn giống x86 nhưng không có các thanh ghi đặc biệt EBP hoặc ESP. Thay vào đó, bạn có thể sử dụng các thanh ghi tổng hợp (ví dụ: R13 - SP - Stack Pointer) để thực hiện các hoạt động liên quan đến xếp ngăn.

3. **Con trỏ lệnh (Instruction Pointer)**: Con trỏ lệnh trong ARM không được thể hiện thông qua một thanh ghi cụ thể như EIP trong kiến trúc x86. Thay vào đó, địa chỉ của lệnh đang thực thi được lưu trữ trong thanh ghi PC.

4. **Lệnh Nhảy (Branch Instructions)**: ARM sử dụng các lệnh nhảy (branch instructions) để thực hiện các nhảy điều kiện và nhảy vô điều kiện giữa các lệnh. Các lệnh nhảy này thường sử dụng thanh ghi PC để xác định địa chỉ đích.

Nhớ rằng, cú pháp và cách sử dụng của các thanh ghi và lệnh trong ngôn ngữ hợp ngữ ARM có thể khác nhau giữa các phiên bản và kiến trúc ARM khác nhau. Tùy thuộc vào phiên bản cụ thể của ARM (ví dụ: ARMv7-A, ARMv8-A), bạn có thể thấy sự khác biệt trong cú pháp và hỗ trợ cho các tính năng cụ thể.

> The calling convention in arm 

In ARM architecture, calling conventions dictate how parameters are passed to functions and how return values are retrieved. There are several common calling conventions used in ARM programming:

1. **AAPCS (ARM Architecture Procedure Call Standard)**:
   - AAPCS is the standard calling convention used in ARM architecture.
   - It defines rules for how parameters are passed to functions, how return values are returned, and how registers are used.
   - The first four arguments (parameters) are passed in registers r0, r1, r2, and r3. Additional arguments are typically passed on the stack.
   - The return value of a function is passed in r0.
   - Registers r4 to r11 are callee-saved, meaning that a function which uses these registers must save their original values and restore them before returning.
   - Registers r0 to r3 are caller-saved, meaning that a function which uses these registers must save their original values if it wants to preserve them across a function call.
   
2. **AAPCS64 (ARMv8-A Architecture Procedure Call Standard)**:
   - AAPCS64 is the 64-bit version of AAPCS used in ARMv8-A architecture.
   - It extends AAPCS to support 64-bit data types and the larger register set.
   - Parameters are passed in registers x0 to x7.
   - The return value of a function is passed in x0.
   - Registers x19 to x28 are callee-saved, while x29 (frame pointer) and x30 (link register) are callee-saved.
   - Registers x0 to x7 are caller-saved.

3. **AAPCS32 (ARMv8-A 32-bit Variant)**:
   - AAPCS32 is used in 32-bit mode on ARMv8-A architecture.
   - It is similar to AAPCS, but it supports 32-bit data types.
   - Parameters are passed in registers w0 to w7.
   - The return value of a function is passed in w0.

It's important to note that specific compilers and environments may have their own variations or extensions to these calling conventions. Always consult the documentation of your specific compiler or toolchain for the exact conventions it follows.

> Lệnh pop một thanh ghi nào đó trong arm = ?

Trong kiến trúc ARM, để "pop" (lấy giá trị ra khỏi ngăn xếp) một thanh ghi, bạn thực hiện các bước sau:

1. Sử dụng lệnh `LDR` hoặc `LDM` để lấy giá trị từ ngăn xếp và đưa vào thanh ghi mong muốn.
2. Sau đó, cần điều chỉnh con trỏ xếp ngăn (stack pointer - SP) bằng cách cộng hoặc trừ một giá trị tùy thuộc vào việc bạn đang thao tác với xếp ngăn từ trên xuống hay từ dưới lên.

Ví dụ, để pop giá trị vào thanh ghi R0, bạn có thể sử dụng lệnh như sau (sử dụng AAPCS - ARM Architecture Procedure Call Standard):

```assembly
LDR R0, [SP], #4
```

Trong đó:
- `LDR R0, [SP], #4` lấy giá trị từ đỉnh xếp ngăn và đưa vào thanh ghi R0. Sau đó, con trỏ xếp ngăn (SP) được tăng lên 4 byte (#4).
- `#4` đại diện cho kích thước của dữ liệu bạn muốn lấy từ xếp ngăn.

Lưu ý rằng việc sử dụng lệnh pop trong ARM sẽ tùy thuộc vào kiến trúc và các quy tắc cụ thể của mã nguồn bạn đang làm việc. Hãy xem tài liệu hướng dẫn của ARM hoặc trình biên dịch mà bạn đang sử dụng để biết cách sử dụng chính xác.

> loopne 0xba9 <voice_test+5>

Lệnh `loopne` là một lệnh trong ngôn ngữ hợp ngữ x86/x86-64 (IA-32/IA-64) được sử dụng để thực hiện vòng lặp có điều kiện dựa trên thanh ghi CX hoặc ECX (tùy thuộc vào chế độ 16-bit hoặc 32-bit).

Trong lệnh của bạn:

```assembly
loopne 0xba9 <voice_test+5>
```

- `loopne` là lệnh vòng lặp có điều kiện (loop if not equal) và chỉ hoạt động khi thanh ghi CX/ECX không bằng 0 và cờ ZF (Zero Flag) không được đặt.
- `0xba9 <voice_test+5>` là địa chỉ đích mà vòng lặp sẽ nhảy đến nếu điều kiện không được thoả mãn. Trong trường hợp này, vòng lặp sẽ nhảy đến địa chỉ `voice_test + 5`.

Lưu ý rằng đoạn mã này đang sử dụng kiến trúc x86/x86-64, không phải ARM. Trong ARM, không có lệnh `loopne`, mà các cấu trúc vòng lặp sẽ được triển khai sử dụng các lệnh `CMP` và các lệnh nhảy tương ứng.

> VD: về gadget pop <rg> ; ret

```arm
"ldr x1, [sp, #0]\n\t"
"ldp x29, x30, [sp], #0\n\t"
"add sp, sp, #0x10"
```

Các lệnh này xuất hiện trong ngôn ngữ hợp ngữ ARM64 (AArch64). Đây là một phân tích ngắn gọn về mỗi lệnh:

1. `"ldr x1, [sp, #0]\n\t"`:
   - Lệnh `ldr` (load register) được sử dụng để nạp giá trị từ bộ nhớ vào thanh ghi.
   - Trong trường hợp này, giá trị tại địa chỉ con trỏ xếp ngăn (stack pointer - SP) đang trỏ tới được nạp vào thanh ghi x1. `[sp, #0]` có nghĩa là địa chỉ tại ngăn đầu tiên từ xếp ngăn (địa chỉ hiện tại của SP).
   - `\n\t` chỉ đơn giản là ký tự xuống dòng và tab, thường được sử dụng để đảm bảo rằng lệnh sau đó sẽ bắt đầu từ vị trí được căn chỉnh.

2. `"ldp x29, x30, [sp], #0\n\t"`:
   - Lệnh `ldp` (load pair) được sử dụng để nạp giá trị từ bộ nhớ vào cặp thanh ghi.
   - Trong trường hợp này, giá trị từ địa chỉ con trỏ xếp ngăn (hiện tại của SP) được nạp vào thanh ghi x29 và x30. `[sp], #0` có nghĩa là địa chỉ tại ngăn đầu tiên từ xếp ngăn được nạp vào các thanh ghi, sau đó SP sẽ tăng lên để trỏ tới ngăn tiếp theo.
   - `\n\t` là ký tự xuống dòng và tab, tương tự như trên.

3. `"add sp, sp, #0x10"`:
   - Lệnh `add` được sử dụng để thực hiện phép cộng.
   - Trong trường hợp này, giá trị của SP sẽ được cộng thêm `0x10` (16 trong hệ thập phân) để tăng địa chỉ của xếp ngăn. Điều này đồng nghĩa với việc giảm kích thước của xếp ngăn đi 16 byte.

Tổng cộng, các lệnh trên có thể được tóm tắt thành việc nạp giá trị từ xếp ngăn vào thanh ghi x1, khôi phục các giá trị từ xếp ngăn vào các thanh ghi x29 và x30, và sau đó điều chỉnh xếp ngăn để trỏ tới ngăn tiếp theo.


