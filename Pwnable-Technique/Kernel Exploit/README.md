# Kernel Exploit 
>Script exploit.c

- Video kiến thức kernel:
	* https://www.youtube.com/watch?v=aFOZIPStugM&list=PLnwLMORCasF5XZPboSq0A5Fwi-6akw7SQ
 	* [pwn-college](https://www.youtube.com/watch?v=j0I2AakUAxk&list=PL-ymxv0nOtqowTpJEW4XTiGQYx6iwa6og) .

- Remote challenge exploit:
  	* you can just zip your exp (binary) via gzip and then base64 encode it.
	* then copy the base64 to remote shell and unzip it.
	* link discord: https://discord.com/channels/814766309866471424/1129970787248517192 giải zer0pts https://2023.ctf.zer0pts.com/tasks/
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>

int main(){
	
}
```

- __Kernel management resource system__
	* File management 
	* Process management
	* I/O management 
	* Memory management 
	* Device management

- __Services Provided by the kernel__

	* Filesystem
	* Syscalls
	* Processes/Threads
	* Privilege levels
	* Network I/O

- __Mitigation__
	* SMEP
	* SMAP
	* KPTI
	* KASLR or FG-KASLR (`cat /proc/kallsyms` sometime)
	
- __DEBUG__
```bash
/home/ctf # cat /proc/modules <request root | not root -> display all null>
vuln 16384 0 - Live 0xffffffffc0000000 (O)
gdb ./vmlinux
gdb> target remote localhost:1234
gdb> add-symbol-file vuln.ko 0xffffffffc0000000
gdb> b swrite
gdb> c
Continuing.

... OR ...

cat /proc/kallsyms | grep '<func_in_module>'
gdb> b *<address>
gdb> target remote :1234
```

- VD về thêm device module vulnerability vào kernel:

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/device.h>
#include <linux/cdev.h>
MODULE_LICENSE("GPL"); // License
static dev_t first;
static struct cdev c_dev;
static struct class *cl;

static ssize_t vuln_read(struct file* file, char* buf, size_t count, loff_t *f_pos){
        return -EPERM; // You don't need to read from the device; so, make it inaccessible for reading
}

static ssize_t vuln_write(struct file* file, const char* buf, size_t count, loff_t *f_pos){
        char buffer[128];
        int i;
        memset(buffer, 0, 128);
        for (i = 0; i < count; i++){
                *(buffer + i) = buf[i];
        }
        printk(KERN_INFO "Got happy data from userspace - %s", buffer);
        return count;
}
static int vuln_open(struct inode* inode, struct file* file) {
        return 0;
}
static int vuln_close(struct inode* inode, struct file* file) {
        return 0;
}
static struct file_operations fileops = {
        owner: THIS_MODULE,
        open: vuln_open,
        read: vuln_read,
        write: vuln_write,
        release: vuln_close,
}; // Create a structure with file operations and handlers
int vuln_init(void){
        alloc_chrdev_region(&first, 0, 1, "vuln"); // Register the /dev device
        cl = class_create( THIS_MODULE, "chardev"); // Create a pointer to the class structure
        device_create(cl, NULL, first, NULL, "vuln"); // Create the device itself
        cdev_init(&c_dev, &fileops);  // Set handlers
        cdev_add(&c_dev, first, 1); // Add the device to the system
        printk(KERN_INFO "Vuln module started\n");
        return 0;
}
void vuln_exit(void){ // Remove and unregister the device
        cdev_del( &c_dev );
        device_destroy( cl, first );
        class_destroy( cl );
        unregister_chrdev_region( first, 1 );
        printk(KERN_INFO "Vuln module stopped??\n");
}
module_init(vuln_init); // Module entry point called by the insmod command
module_exit(vuln_exit); // Module exit point called by the rmmod command
```

------------------------------------------------------------------------

[+] [FG-KASLR lkmidas](https://lkmidas.github.io/posts/20210205-linux-kernel-pwn-part-3/#about-kaslr-and-fg-kaslr) .

[+] [KASLR - chall Easy Kernel - k3rn3l4rmy](https://ctftime.org/writeup/31392) . 

 

