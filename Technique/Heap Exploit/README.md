# INTRO

* unlink() protostar : exploit unsafe unlink() khai thác vào hành vi merge hai khối free cạnh nhau (vì mặt lý thuyết thì không có hai freed chunk nằm cạnh nhau về mặt vật lý), trước khi merge thì unlink freed chunk khỏi double linked list rồi mới merge với chunk đang tiến hành free(chunk này nằm ngay phía trước hoặc sau freed chunk). `libc <= 2.23` | size in previos_chunk is size request chunk + metadata

```
/* Take a chunk off a bin list.  */
static void
unlink_chunk (mstate av, mchunkptr p)
{
  if (chunksize (p) != prev_size (next_chunk (p)))
    malloc_printerr ("corrupted size vs. prev_size");
  mchunkptr fd = p->fd;
  mchunkptr bk = p->bk;
  if (__builtin_expect (fd->bk != p || bk->fd != p, 0))
    malloc_printerr ("corrupted double-linked list");
  fd->bk = bk;
  bk->fd = fd;
if (!in_smallbin_range (chunksize_nomask (p)) && p->fd_nextsize != NULL)
```

* unsortbins 
```
đầu tiên free cho nó vào unsortbins

xong cái thì modify cái bk trỏ vào cái (địa chỉ mình muốn - 0x10)

xong malloc lại đúng size đấy

thì cái địa chỉ của mình nó ghi đè bằng cái fd

thưởng của unsortbins thì nó là main_arena+88 

có hai trường hợp là ghi đè __free_hook hoặc __malloc_hook

xong đè __free_hook thì phải có cái offset nào đấy gần đấy có data phù hợp để fake cái size double free nó không lỗi.

thì dùng unsortbins đè trước cái __free_hook

xong doublefree vào đấy để ghi đè system vào __free_hook

rồi gọi free(địa chỉ chuỗi /bin/sh)

thì nó cal __free_hook trước xong nó call free

khi đó __free_hook(*binsh) = system(*binsh) => getshell.
```

*

> Script interactive heap exploit template.

```python
def Create(index, size, data):
        p.sendlineafter(b'>', str(1))
        p.sendlineafter(b'Index: ', str(index))
        p.sendlineafter(b'Size: ', str(size))
        p.sendlineafter(b'Data: ', data)

def Show(index):
        p.sendlineafter(b'>', str(2))
        p.sendlineafter(b'Index: ', str(index))
        p.recvuntil(b'Data: ')
        leak = p.recvuntil(b'\n')
        return leak.replace(b'\n', b'')

def Edit(index, data):
        p.sendlineafter(b'>', str(3))
        p.sendlineafter(b'Index: ', str(index))
        p.sendlineafter(b'Data: ', data)

def Delete(index):
        p.sendlineafter(b'>', str(4))
        p.sendlineafter(b'Index: ', str(index))

```
```python
def create(idx, sz, data):
    p.sendlineafter(b'>', b'1')
    p.sendlineafter(b'Index', str(idx).encode())
    p.sendlineafter(b'Size', str(sz).encode())
    p.sendlineafter(b'Data', data)

def show(idx):
    p.sendlineafter(b'>', b'2')
    p.sendlineafter(b'Index', str(idx).encode())
    p.recvuntil(b'Data: ')
    leak = p.recvuntil(b'\n')
    return leak.replace(b'\n', b'')
def edit(idx, data):
    p.sendlineafter(b'>', b'3')
    p.sendlineafter(b'Index', str(idx).encode())
    p.sendlineafter(b'Data', data)

def delete(idx):
    p.sendlineafter(b'>', b'4')
    p.sendlineafter(b'Index', str(idx).encode())
```
```python
u64(show().strip().ljust(8,b'\x00')))

# Trong 1 số trường hợp cần loại bỏ junk ở đầu leak => 
def show(idx, data_before):
    p.send(b'2')
    p.sendafter(b'Index:',str(idx).encode())
    p.recvuntil(b'Data = ' + data_before)
    return p.recvline()
    
# p = gdb.debug('./vuln', gdbscript='''
#       b *menu
#       b *allocate
#       b *rfree
#       b *reallocate
# ''')
```



